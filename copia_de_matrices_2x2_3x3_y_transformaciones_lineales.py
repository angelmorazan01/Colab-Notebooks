# -*- coding: utf-8 -*-
"""Copia_de_Matrices_2x2_3x3_y_Transformaciones_Lineales.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V2f8gP888mrIC1hQI1slkcDxrXD_kUJV

# Matriz Inversa

Recodemos que cuando el determinante asociado a una matriz cuadrada es distinto de cero, la matriz tiene un inverso multiplicativo. Como los casos que nos interesa en este notebook son los de matrices de $2 \times 2$ y de $3 \times 3$, encontraremos explícitamente la forma de la matriz inversa en el caso de $3 \times 3$ y pediremos al usuario hacer lo propio para el caso de $2 \times 2$.

Supongamos que el determinante $\Delta$ de la matriz original no es cero, $\Delta \neq 0$, y planteemos la existencia de otra matriz, la matriz inversa, cuyo producto con la original sea el elemento neutro, es decir,

![](https://i.imgur.com/68Hdl0j.png)

Como el producto de la izquierda es igual a la matriz de la derecha, las
entradas correspondientes deben coincidir y eso nos lleva a plantear 3 sistemas
de 3 ecuaciones con 3 incógnitas, cada uno de los cuales tiene como determinante
el de la matriz original. Uno de esos sistemas es el siguiente (recuerde
que $a,\ldots,i$ están dados, y que $p,\ldots,x$ son las incógnitas):

![](https://i.imgur.com/24wm4cP.png)

Podemos aplicar la regla de Cramer para obtener

![](https://i.imgur.com/JfGOKsm.png)

El lector puede comprobar que
>$p$ es el cociente del *cofactor* de a entre $\Delta$;  
>$s$ es el cociente del *cofactor* de b entre $\Delta$;  
>$v$ es el cociente del *cofactor* de c entre $\Delta$.

De hecho, la forma de obtener cada elemento de la matriz inversa es la siguiente:

1. Tómese el elemento de la matriz original que ocupa el lugar simétrico
respecto a la diagonal principal (de arriba a la izquierda a abajo a la derecha).
2. Fórmese el *cofactor* de dicho elemento simétrico.
3. Divídase el número anterior entre el determinante $\Delta$.

Entonces, la matriz inversa tiene la forma:

![](https://i.imgur.com/KERqQ7E.png)

Recordemos que la matriz en el lado derecho de la igualdad anterior es la traspuesta de la matriz de cofactores multiplicada por el determinante $\Delta$. Por tanto, en general, dada una matriz $M$ de tamaño $3 \times 3$ se tiene que

$$M^{-1} = \tfrac{1}{\det{M}}\mathrm{Cof}(M)^{\top}, \qquad (1)$$

donde $\mathrm{Cof}(M)$ denota la matriz de cofactores de $M$.

Ahora bien, como se ha de suponer ya, algunas librerias de Python, tales como `NumPy` o `SymPy`, tienen funciones integradas que nos permiten calcular la inversa de una matriz de manera inmediata. Aún así, con la intención de continuar nuestra experiencia con programación en Python, procederemos a implementar una función que nos permita calcular la inversa de una matriz $3 \times 3$ utilizando la fórmula $(1)$. A pesar de que por el momento nos interesan solamente matrices con entradas numéricas, usaremos el módulo de `SymPy` para construir tal función por si nos es necesario utilizarla después para calcular inversas de matrices simbólicas:
"""

import sympy as sym
import itertools as itools # Para obtener el producto cartesiano de dos conjuntos

def matriz_inversa_3x3(matriz):
    matriz = sym.Matrix(matriz) # Convertir a matriz simbólica
    if matriz.det() != 0:
        matriz_cofactores = sym.zeros(3, 3) # Crear la matriz CERO de 3x3 (simbólica)
        for c in itools.product({0,1,2}, {0,1,2}): # Generar el producto cartesiano {1,2,3}x{1,2,3}
            matriz_cofactores[c] = matriz.cofactor(c[0], c[1]) # Asignar a la entrada [i,j] el cofactor ij de 'matriz'
        return (1/matriz.det()) * matriz_cofactores.transpose() # Implementación de la fórmula (1)
    return 'La matriz no es invertible' # ¿Qué pasó en el 'else' para el 'if'?

"""**Nota.** Si bien lo anterior es un código para calcular la inversa 'casi a mano', hemos usado la función `cofactor` de `SymPy` para el cálculo de cofactores (como su nombre lo indica).

**Ejemplo.** Calculemos la inversa de la matriz

$$
M = \left(
  \begin{array}{ccr}
    3 & 0 & 2 \\
    2 & 0 & -2 \\
    0 & 1 & 1
  \end{array}
\right).
$$
"""

M = [[3,0,2],[2,0,-2],[0,1,1]]
matriz_inversa_3x3(M)

"""**Ejercicio 1.** Implemente una función que retorne la inversa de una matriz de tamaño $2 \times 2$."""



"""**Ejercicio 2.** Calcule la inversa de la siguiente matriz usando la función que implementó:

$$
M = \left(
  \begin{array}{rr}
    -2 & 0 \\
    0 & -2
  \end{array}
\right).
$$
"""



"""# Matriz de una transformación lineal

Cuando dos conjuntos $A$ y $B$ tienen un mismo tipo de estructura, dada una
función entre ellos, $T: A \mapsto B$, es importante saber si la función *respeta* la estructura.

El plano y el espacio cartesianos tienen varios tipos de estructuras, en particular la de espacio vectorial, y hemos visto que una condición necesaria y
suficiente para que un subconjunto no vacío de un espacio vectorial sea espacio
vectorial con las operaciones restringidas, es que sea cerrado bajo combinaciones lineales. Cuando una aplicación entre dos espacios vectoriales lleva combinaciones lineales de vectores en la combinación lineal de las imágenes de los vectores con los mismos coeficientes, está conservando la propiedad esencial de la estructura de espacio vectorial; éstas son las llamadas *transformaciones lineales*.

Así como el usuario seguramente conocía varios ejemplos de espacios vectoriales aún antes de serle presentado el concepto, así también descubrirá que conoce varios ejemplos de transformaciones lineales. Precisemos primero la definición.

**Definición.** Una aplicación $T: V \mapsto W$ entre dos espacios vectoriales es una *transformación lineal* si la imagen de una combinación lineal de vectores en $V$ puede obtenerse como la combinación lineal en $W$ de las imágenes de los vectores originales con los mismos coeficientes; en símbolos,

$$T(\lambda u + \mu v) = \lambda T(u) + \mu T(v),$$

para cualesquiera $u,v \in V$; con $\lambda,\mu \in \mathbb{R}$.

Como es sabido basta conocer las imágenes bajo $T$ de los vectores de una base en $V$ para poder determinar la imagen (bajo $T$) de cualquier otro vector. Pero de hecho, si se *fija* una base en el dominio y una en el contradominio
de $T$ hay un instrumento auxiliar con el cual identificarla: las matrices.

El teorema siguiente muestra cómo se construye la matriz de una transformación lineal cuando se especifican las bases en el dominio y el contradominio
de una tal transformaci´on.

**Teorema** Si $V$ y $W$ son dos espacios vectoriales de dimensión finita y $T:
V \mapsto W$ es una transformación lineal, dadas bases $\{e_1, e_2, \ldots, e_n\}$ de $V$ y $\{f_1, f_2, \ldots, f_m\}$ de $W$, la matriz cuyas columnas son $\{T(e_1),T(e_2),\ldots,T(e_n)\}$ expresados en coordenadas respecto a la base de $W$, permite obtener la imagen de cualquier otro vector $v$ bajo $T$ con sólo multiplicar dicha matriz por el vector columna de las coordenadas $(a_1, a_2,\ldots,a_n)$ de $v$ respecto a la base dada de $V$ (obsérvese que la multiplicación tiene sentido sólo si la matriz está a la izquierda del vector columna); es decir,

![](https://i.imgur.com/0kDUN1h.png)

**Observación.** Es muy importante notar que la matriz *depende* de las bases
elegidas tanto en el dominio como en el contradominio, aunque en este notebook,
salvo que se especifique lo contrario, el dominio y el contradominio serán
iguales, ya sea $\mathbb{R}^2$, $\mathbb{R}^3$ ó $\mathbb{R}^n$, y en cada caso se usará siempre la base canónica.

* A continuación implementaremos un código para construir las matrices asociadas, en las *bases canónicas*, de transformaciones lineales de $\mathbb{R}^n$ a $\mathbb{R}^n$:
"""

import sympy as sym

def matriz_de(transformacion):
    transformacion = sym.sympify(transformacion)
    Matriz = sym.Matrix([]) # Crear un matriz 'vacía'
    for key in transformacion:
        Matriz = Matriz.col_insert(key.index(1), sym.Matrix(transformacion[key]))
    return Matriz

"""**Nota.** De no marcar error la celda de código, lo siguiente debería ir como documentación de la función `matriz_de_T`:

    ''' 
    Construye la matriz de un operador lineal en R^n respecto a la base canónica de este espacio vectorial.

        Parámetros
        ==========
        :transformacion:
            Es un diccionario que tiene como llaves/claves tuplas que emulan los elementos de la base canónica en R^n
            y donde los respectivos valores de las llaves/claves son también tuplas que emulan la imagen del elemento básico 
            bajo (la correspondiente) transformacion lineal.
        
        Returns
        =======
            Una matriz simbólica.
    '''

A continuación construiremos las matrices asociadas, en las bases canónicas, a los ejemplos de transformaciones lineales que vimos en el inciso anterior.

**Ejemplo 1.** Para la homotecia de razón $\mathbb{R}^2$, se tiene
>$H_{k}(1, 0) = (k, 0)$,  
>$H_{k}(0, 1) = (0, k)$,

entonces la matriz de dicha homotecia es:
"""

H_k = {(1,0): ('k',0), (0,1): (0,'k')}

matriz_de(H_k)

"""**Ejemplo 2.** Para la proyección de $\mathbb{R}^3$ en el plano $XY$, las imágenes de los vectores básicos son
>$\Pi_{XY}(1, 0, 0) = (1, 0, 0)$,  
>$\Pi_{XY}(0, 1, 0) = (0, 1, 0)$,  
>$\Pi_{XY}(0, 0, 1) = (0, 0, 0)$,

por lo que la matriz de esta proyección es:
"""

P_XY = {(1,0,0): (1,0,0), (0,1,0): (0,1,0), (0,0,1): (0,0,0)}

matriz_de(P_XY)

"""**Ejemplo 3.** Para la rotación en $\mathbb{R}^2$ con centro en el origen por un ángulo $\phi$, se tiene
>$R_{0_{\phi}}(1, 0) = (\cos{\phi}, \sin{\phi})$,  
>$R_{0_{\phi}}(0, 1) = (-\sin{\phi}, \cos{\phi})$, 

por tanto, la matriz correspondiente es:
"""

R0_phi = {(1,0): ('cos(phi)','sin(phi)'), (0,1): ('-sin(phi)','cos(phi)')}

matriz_de(R0_phi)

"""Ahora, para obtener la imagen de un punto/vector $(x, y) \in \mathbb{R}^2$ podemos proceder de la siguiente manera:"""

x, y = sym.symbols('x y')

matriz_de(R0_phi)*sym.Matrix([[x],[y]])

"""**Ejemplo 4.** Para la reflexión en $\mathbb{R}^2$ respecto a la recta por el origen que forma un ángulo $\theta$ respecto a la parte positiva del eje $X$, los transformados de los vectores básicos son
>$Re_{l(\theta)}(1, 0) = (\cos{2\theta}, \sin{2\theta})$,  
>$Re_{l(\theta)}(0, 1) = (\sin{2\theta}, -\cos{2\theta})$, 

por lo que la matriz correspondiente es:
"""

Re_theta = {(1,0): ('cos(2*theta)','sin(2*theta)'), (0,1): ('sin(2*theta)','-cos(2*theta)')}

matriz_de(Re_theta)

"""El transformado de $(x, y)$ se obtiene mediante la multiplicación siguiente:"""

x, y = sym.symbols('x y')

matriz_de(Re_theta)*sym.Matrix([[x],[y]])

"""**Ejercicio.** Calcule las matrices de los `Ejemplos 5, 6 y 7` de las páginas 289 y 290 del libro *GEOMETRÍA ANALÍTICA: Una introducción a la geometría* de Ana Irene Ramírez-Galarza."""